---
title: "Pnpm笔记"
date: 2022-08-11T11:51:32+08:00
draft: true
hiddenFromHomePage: true
categories: ["note"]
tags: ["note"]
---
#### 高效利用磁盘空间
> 内部使用`基于内容寻址`的文件系统来存储磁盘上的所有的文件
+ 不会重复安装同一个包，磁盘中只有一个地方写入，后面再次使用都会直接使用`Hard Link`
  + 关于`Hard Link`,Linux链接分为两种,一种被称为`Hard Link`，另一种被称为`Symbolic Link`
    + `Hard Link` 通过索引节点来进行连接。在Linux的文件系统中，保存在磁盘分区的文件都会分配一个索引节点号，硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，该文件只有当与之相关的所有硬连接文件均被删除时才会被删除，当移动或者删除原始文件时，硬链接不会被破坏。
    + `Symbolic Link` 也叫软链接，它其实是一个特殊的文件，它的内容是另一文件的位置信息。
+ 即使一个包的不同版本，pnpm也会极大程度的复用之前的版本代码，比如`a`包之前有10个文件，更新版本后新增了一个文件，pnpm并不会重新写入11个文件，而是保留原来的`hardlink`，只写入一个新增的文件。

#### 安全性高
在使用npm/yarn的时候，由于node_module的扁平结构，如果A依赖B，B依赖C，那么A当中是可以直接使用C的。

### npm/yarn install 原理
#### 包如何到达项目node_modules
1. 依赖包的版本区间解析为某个具体的版本号
2. 下载对应版本依赖的tar包到本地离线镜像
3. 将依赖从离线镜像解压到本地缓存
4. 将依赖从缓存拷贝到当前目录的node_modules目录

`node_modules`是扁平化的，不再有很深层次的嵌套关系，所有的依赖都被拍平到`node_modules`目录下，不再有很深层次的嵌套关系。这样在安装新的包时，根据 node require 机制，会不停往上级的`node_modules`当中去找，如果找到相同版本的包就不会重新安装，解决了大量包重复安装的问题，而且依赖层级也不会太深。还是存在的问题：
1. 扁平化算法复杂
2. package非法访问

#### node_modules 内部如何管理依赖

